<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Puff Puff Paint</title>
    <!-- Import Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Bitcoin Connect Integration (Updated to latest version) -->
    <script type="module">
      import {
        init,
        launchModal,
        launchPaymentModal,
        requestProvider,
        onConnected,
        onDisconnected
      } from "https://esm.sh/@getalby/bitcoin-connect@3.12.0";
      // Initialize Bitcoin Connect with full options
      init({ 
        appName: "Puff Puff Paint", 
        showBalance: true,
        nostrProfile: true
      });
      onConnected((provider) => {
        console.log("[Bitcoin Connect] Connected:", provider);
        window.webln = provider;
      });
      onDisconnected(() => {
        console.log("[Bitcoin Connect] Disconnected");
        window.webln = null;
      });
    </script>
    <style>
      /* --- Reset & Base --- */
      * { margin: 0; padding: 0; box-sizing: border-box; }
      :root {
        --primary: #EF8C56;
        --primary-dark: #D97B45;
        --secondary: #6A7FDB;
        --text: #1f1f1f;
        --text-light: #666;
        --background: #f5f5f5;
        --card: #fff;
        --border: #eee;
        --shadow: rgba(0,0,0,0.1);
        --radius: 10px;
      }
      body {
        background-color: var(--background);
        color: var(--text);
        font-family: 'Inter', -apple-system, system-ui, sans-serif;
        padding-bottom: 80px;
        line-height: 1.5;
      }
      /* --- Header --- */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: var(--primary);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 100;
        box-shadow: 0 2px 4px var(--shadow);
      }
      .header .left,
      .header .center,
      .header .right {
        flex: 1;
      }
      .header .left { text-align: left; }
      .header .center { text-align: center; }
      .header .right { text-align: right; }
      .header button {
        background: none;
        border: none;
        color: #fff;
        font-size: 18px;
        font-weight: 500;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 20px;
        transition: background 0.2s;
      }
      .header button:hover {
        background: rgba(255,255,255,0.1);
      }
      #profile-pic img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
        cursor: pointer;
        border: 2px solid white;
      }
      /* --- Main Container --- */
      .container {
        max-width: 600px;
        margin: 80px auto 20px;
        padding: 0 15px;
      }
      /* --- Compose Card --- */
      .compose-card {
        background: var(--card);
        border-radius: var(--radius);
        padding: 15px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px var(--shadow);
      }
      .compose-card .note-header {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .compose-card .note-header img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        cursor: pointer;
      }
      .compose-card textarea {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: calc(var(--radius) - 4px);
        padding: 12px;
        margin-top: 12px;
        font-size: 16px;
        font-family: 'Inter', sans-serif;
        resize: vertical;
        outline: none;
      }
      .compose-card textarea:focus {
        border-color: var(--primary);
      }
      .compose-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 12px;
      }
      .upload-button {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .upload-button:hover {
        opacity: 1;
      }
      .publish-button {
        background: var(--primary);
        color: #fff;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 500;
        transition: background 0.2s, transform 0.2s;
      }
      .publish-button:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }
      /* --- Note Card --- */
      .note-card {
        background: var(--card);
        border-radius: var(--radius);
        margin-bottom: 15px;
        box-shadow: 0 2px 8px var(--shadow);
        overflow: hidden;
        transition: transform 0.2s;
      }
      .note-card:hover {
        transform: translateY(-2px);
      }
      .note-card .note-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 15px;
      }
      .note-card .note-header img {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        cursor: pointer;
        object-fit: cover;
      }
      .author-info { 
        flex: 1; 
        cursor: pointer;
      }
      .author-name { 
        font-weight: 600; 
        color: var(--text);
      }
      .timestamp { 
        font-size: 13px; 
        color: var(--text-light); 
      }
      .note-content { 
        padding: 0 15px 15px; 
        font-size: 16px; 
        word-break: break-word;
      }
      .note-id {
        font-size: 11px;
        color: var(--text-light);
        padding: 0 15px 5px;
        font-family: monospace;
        opacity: 0.7;
        cursor: pointer;
      }
      .note-id:hover {
        opacity: 1;
      }
      .media-container {
        width: 100%;
        display: grid;
        gap: 2px;
        background: var(--background);
        margin-bottom: 10px;
      }
      .media-container.single { max-height: 500px; }
      .media-container.single img {
        width: 100%;
        height: auto;
        max-height: 500px;
        object-fit: contain;
      }
      .media-container.multiple { grid-template-columns: repeat(2, 1fr); }
      .media-container.multiple img {
        width: 100%;
        aspect-ratio: 1;
        object-fit: cover;
      }
      .media-preview {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 8px;
        margin: 10px 0;
      }
      .media-preview div { position: relative; }
      .media-preview img {
        width: 100%;
        display: block;
        border-radius: calc(var(--radius) - 4px);
      }
      .remove-btn {
        position: absolute;
        top: 0;
        right: 0;
        background: rgba(0,0,0,0.6);
        color: #fff;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 2px 6px;
        border-top-right-radius: calc(var(--radius) - 4px);
        border-bottom-left-radius: calc(var(--radius) - 4px);
      }
      /* --- Note Actions (Icons & Numeric Badge) --- */
      .note-actions {
        display: flex;
        gap: 20px;
        padding: 10px 15px;
        border-top: 1px solid var(--border);
        align-items: center;
      }
      .note-actions .action {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 18px;
        color: var(--text-light);
        cursor: pointer;
        transition: color 0.2s ease;
        padding: 5px;
        border-radius: 5px;
      }
      .note-actions .action:hover {
        color: var(--primary);
        background: rgba(239, 140, 86, 0.1);
      }
      .note-actions .action span { 
        font-size: 14px; 
        color: var(--text); 
        font-weight: 500;
      }
      .note-actions .action.user-zapped {
        color: var(--primary);
      }
      .note-actions .action.user-zapped span {
        color: var(--primary);
        font-weight: bold;
      }
      /* --- Replies & Threads --- */
      .replies-container {
        border-top: 1px solid var(--border);
        background: rgba(245, 245, 245, 0.5);
        padding: 0;
        display: none;
      }
      /* The reply input block is now created dynamically only when a thread is toggled */
      .reply-input {
        display: flex;
        flex-direction: column;
        gap: 5px;
        padding: 10px 15px;
        border-bottom: 1px solid var(--border);
      }
      .reply-input textarea {
        width: 100%;
        border: 1px solid #ccc;
        border-radius: 20px;
        padding: 8px 12px;
        font-size: 14px;
        font-family: 'Inter', sans-serif;
        resize: none;
        outline: none;
        min-height: 40px;
      }
      .reply-input textarea:focus {
        border-color: var(--primary);
      }
      .reply-card {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 12px 15px;
        border-bottom: 1px solid var(--border);
        transition: background 0.2s;
      }
      .reply-card:hover {
        background: rgba(255, 255, 255, 0.7);
      }
      .reply-card:last-child {
        border-bottom: none;
      }
      .reply-card img {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        object-fit: cover;
      }
      .reply-content { 
        font-size: 14px; 
        flex: 1;
      }
      .reply-content .author-info {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .reply-content .author-name {
        cursor: pointer;
      }
      .reply-content .timestamp {
        font-size: 12px;
      }
      .reply-id {
        font-size: 10px;
        color: var(--text-light);
        font-family: monospace;
        margin-top: 3px;
        opacity: 0.7;
        cursor: pointer;
      }
      .reply-id:hover {
        opacity: 1;
      }
      .reply-actions {
        display: flex;
        gap: 15px;
        margin-top: 5px;
      }
      .reply-actions .action {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 14px;
        color: var(--text-light);
        cursor: pointer;
        transition: color 0.2s ease;
      }
      .reply-actions .action:hover {
        color: var(--primary);
      }
      .reply-actions .action span {
        font-size: 12px;
      }
      .reply-actions .action.user-zapped {
        color: var(--primary);
      }
      /* --- Modals Styling --- */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 300;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(5px);
      }
      .modal-content {
        background: var(--card);
        padding: 20px;
        border-radius: var(--radius);
        width: 90%;
        max-width: 450px;
        max-height: 85vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      }
      .close-modal {
        position: absolute;
        top: 15px; right: 20px;
        font-size: 22px;
        cursor: pointer;
        background: none;
        border: none;
        color: var(--text-light);
        z-index: 10;
      }
      .close-modal:hover {
        color: var(--text);
      }
      
      /* --- Zap Modals --- */
      .zap-modal-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .zap-amount-options {
        display: flex;
        gap: 10px;
        justify-content: space-around;
      }
      .zap-amount-btn {
        background: var(--primary);
        color: #fff;
        border: none;
        padding: 8px 0;
        width: 60px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: background 0.2s, transform 0.2s;
      }
      .zap-amount-btn:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
      }
      .zap-slider-container {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      #zap-slider { 
        flex: 1; 
        -webkit-appearance: none;
        width: 100%;
        height: 6px;
        border-radius: 5px;
        background: #ddd;
        outline: none;
      }
      #zap-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
      }
      .zap-slider-value { 
        font-size: 16px;
        font-weight: 500;
        color: var(--primary);
        min-width: 80px;
        text-align: right;
      }
      .zap-custom-container {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      #zap-custom {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 6px;
        font-family: 'Inter', sans-serif;
      }
      #zap-custom:focus {
        border-color: var(--primary);
        outline: none;
      }
      .zap-comment {
        margin-top: 10px;
      }
      .zap-comment textarea {
        width: 100%;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 14px;
        font-family: 'Inter', sans-serif;
        resize: none;
        height: 60px;
      }
      .zap-comment textarea:focus {
        border-color: var(--primary);
        outline: none;
      }
      .zap-modal-footer {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
      }
      
      /* --- Zappers Modal --- */
      .zappers-modal {
        min-width: 350px;
      }
      .zappers-header {
        font-weight: 600;
        font-size: 18px;
        margin-bottom: 15px;
        text-align: center;
      }
      .zappers-total {
        display: flex;
        justify-content: space-between;
        background: rgba(239, 140, 86, 0.1);
        padding: 12px 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        align-items: center;
      }
      .zappers-amount {
        font-weight: 600;
        color: var(--primary);
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .zappers-list {
        max-height: 50vh;
        overflow-y: auto;
      }
      .zapper-card {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px;
        border-bottom: 1px solid var(--border);
        transition: background 0.2s;
      }
      .zapper-card:hover {
        background: rgba(245, 245, 245, 0.7);
      }
      .zapper-card img {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        object-fit: cover;
      }
      .zapper-info {
        flex: 1;
        cursor: pointer;
      }
      .zapper-name {
        font-weight: 500;
      }
      .zapper-time {
        font-size: 12px;
        color: var(--text-light);
      }
      .zapper-amount {
        font-weight: 600;
        color: var(--primary);
        display: flex;
        align-items: center;
        gap: 3px;
      }
      
      /* --- Profile Modal --- */
      .profile-modal {
        width: 450px;
        padding: 0;
        overflow: hidden;
      }
      .profile-header {
        position: relative;
      }
      .profile-banner {
        width: 100%;
        height: 160px;
        object-fit: cover;
        background-color: var(--secondary);
      }
      .profile-avatar {
        position: absolute;
        bottom: -50px;
        left: 30px;
        width: 100px;
        height: 100px;
        border-radius: 50%;
        border: 4px solid white;
        object-fit: cover;
      }
      .profile-details {
        margin-top: 60px;
        padding: 0 20px 20px;
      }
      .profile-name {
        font-size: 20px;
        font-weight: 700;
      }
      .profile-npub {
        font-size: 12px;
        color: var(--text-light);
        font-family: monospace;
        margin-bottom: 15px;
        word-break: break-all;
        cursor: pointer;
      }
      .profile-bio {
        margin-bottom: 20px;
        line-height: 1.6;
        white-space: pre-line;
      }
      .profile-actions {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      .follow-button, .unfollow-button, .zap-profile-button {
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
        border: none;
        font-family: 'Inter', sans-serif;
      }
      .follow-button {
        background: var(--primary);
        color: white;
      }
      .follow-button:hover {
        background: var(--primary-dark);
      }
      .unfollow-button {
        background: #f1f1f1;
        color: var(--text);
        border: 1px solid #ddd;
      }
      .unfollow-button:hover {
        background: #e5e5e5;
      }
      .zap-profile-button {
        background: #ffde59;
        color: #333;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .zap-profile-button:hover {
        background: #f1d34a;
      }
      .profile-stats {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
      }
      .profile-stat {
        text-align: center;
      }
      .profile-stat-value {
        font-weight: 600;
        font-size: 16px;
      }
      .profile-stat-label {
        font-size: 12px;
        color: var(--text-light);
      }
      .profile-links {
        margin-bottom: 20px;
      }
      .profile-link {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
        font-size: 14px;
      }
      .profile-link a {
        color: var(--secondary);
        text-decoration: none;
      }
      .profile-link a:hover {
        text-decoration: underline;
      }
      .profile-notes {
        margin-top: 20px;
      }
      .profile-notes-title {
        font-weight: 600;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .profile-notes-title a {
        font-size: 14px;
        color: var(--primary);
        text-decoration: none;
      }
      .profile-note {
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-bottom: 10px;
        background: #fafafa;
        transition: background 0.2s;
      }
      .profile-note:hover {
        background: white;
      }
      .profile-note-content {
        font-size: 14px;
        margin-bottom: 5px;
      }
      .profile-note-time {
        font-size: 12px;
        color: var(--text-light);
      }
      
      /* --- Floating Compose Button --- */
      .floating-compose {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 60px;
        height: 60px;
        background: var(--primary);
        color: #fff;
        border: none;
        border-radius: 50%;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(239, 140, 86, 0.4);
        transition: transform 0.2s, background 0.2s;
        z-index: 90;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .floating-compose:hover {
        transform: scale(1.1);
        background: var(--primary-dark);
      }
      
      /* --- Toast Notifications --- */
      .toast {
        position: fixed;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: #fff;
        padding: 12px 20px;
        border-radius: 8px;
        opacity: 0;
        transition: opacity 0.5s ease;
        z-index: 400;
        font-weight: 500;
        font-size: 14px;
        max-width: 80%;
        text-align: center;
      }
      
      /* --- Loading Indicator --- */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 500;
        display: none;
        backdrop-filter: blur(3px);
      }
      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .inline-loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(239, 140, 86, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary);
        animation: spin 1s ease-in-out infinite;
        margin: 0 auto;
        vertical-align: middle;
      }
      
      /* --- Copy Button --- */
      .copy-button {
        background: none;
        border: none;
        cursor: pointer;
        color: var(--text-light);
        display: inline-flex;
        align-items: center;
        margin-left: 5px;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .copy-button:hover {
        opacity: 1;
      }
      
      /* --- Empty State --- */
      .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--text-light);
      }
      .empty-state-icon {
        font-size: 48px;
        margin-bottom: 15px;
        opacity: 0.3;
      }
      .empty-state-text {
        font-size: 16px;
        margin-bottom: 20px;
      }
      
      /* --- Responsive Adjustments --- */
      @media (max-width: 480px) {
        .note-actions { gap: 15px; }
        .reply-input textarea { font-size: 16px; }
        .profile-modal, .modal-content {
          width: 95%;
          max-height: 85vh;
        }
        .profile-avatar {
          width: 80px;
          height: 80px;
          bottom: -40px;
        }
        .profile-details {
          margin-top: 50px;
        }
      }
    </style>
  </head>
  <body>
    <!-- HEADER -->
    <div class="header">
      <div class="left">
        <button onclick="window.location.href='index.html'">🏡</button>
      </div>
      <div class="center">
        <button onclick="refreshFeed()">Feed</button>
      </div>
      <div class="right" id="profile-pic" onclick="openProfileModal(npub)">
        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23ccc'/%3E%3C/svg%3E" alt="Profile">
      </div>
    </div>

    <!-- MAIN CONTAINER -->
    <div class="container">
      <!-- Compose Card for New Note -->
      <div id="compose" class="compose-card">
        <div class="note-header">
          <img id="compose-avatar" class="avatar" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23ccc'/%3E%3C/svg%3E" alt="Profile" onclick="openProfileModal(npub)">
          <div class="author-info">
            <div id="compose-name" class="author-name"></div>
          </div>
        </div>
        <textarea id="content" class="compose-text" placeholder="What's on your mind?" rows="3"></textarea>
        <div id="media-preview" class="media-preview"></div>
        <div class="compose-actions">
          <input type="file" accept="image/*" id="image-input" style="display: none;" multiple />
          <button class="upload-button" onclick="document.getElementById('image-input').click()">📷</button>
          <button class="publish-button" onclick="publishNote()">Post</button>
        </div>
      </div>
      
      <!-- Feed of Notes -->
      <div id="notes"></div>
      
      <!-- Empty State (shown when no notes are available) -->
      <div id="empty-state" class="empty-state" style="display: none;">
        <div class="empty-state-icon">📝</div>
        <div class="empty-state-text">No notes found. Be the first to post!</div>
      </div>
    </div>

    <!-- Floating Compose Button -->
    <button class="floating-compose" onclick="scrollToCompose()">+</button>

    <!-- SETTINGS MODAL (Bitcoin Connect) -->
    <div id="settingsModal" class="modal-overlay">
      <div class="modal-content">
        <button class="close-modal" onclick="closeSettingsModal()">&times;</button>
        <h2 style="margin-bottom: 20px;">User Settings</h2>
        <!-- Bitcoin Connect web component -->
        <bc-button title="Connect Bitcoin Wallet" onclick="launchModal()"></bc-button>
      </div>
    </div>

    <!-- ZAP MODAL (for zapping notes) -->
    <div id="zapModal" class="modal-overlay">
      <div class="modal-content">
        <button class="close-modal" onclick="closeZapModal()">&times;</button>
        <h3 style="margin-bottom: 15px;">Send Zap</h3>
        <div class="zap-modal-container">
          <div class="zap-amount-options">
            <button class="zap-amount-btn" data-amount="100" onclick="setZapAmount(100)">100</button>
            <button class="zap-amount-btn" data-amount="500" onclick="setZapAmount(500)">500</button>
            <button class="zap-amount-btn" data-amount="1000" onclick="setZapAmount(1000)">1000</button>
            <button class="zap-amount-btn" data-amount="5000" onclick="setZapAmount(5000)">5000</button>
          </div>
          <div class="zap-slider-container">
            <input type="range" id="zap-slider" min="1" max="10000" value="1000" onchange="updateZapSlider(this.value)" oninput="updateZapSlider(this.value)" />
            <span id="zap-slider-value" class="zap-slider-value">1000 ⚡</span>
          </div>
          <div class="zap-custom-container">
            <input type="number" id="zap-custom" placeholder="Custom amount" min="1" />
            <button class="zap-amount-btn" id="zap-custom-btn" onclick="setZapCustom()">Set</button>
          </div>
          <div class="zap-comment">
            <textarea id="zap-message" placeholder="Add a comment (optional)"></textarea>
          </div>
        </div>
        <div class="zap-modal-footer">
          <button class="publish-button" onclick="closeZapModal()">Cancel</button>
          <button class="publish-button" onclick="confirmZap()">Send Zap</button>
        </div>
      </div>
    </div>
    
    <!-- PROFILE MODAL -->
    <div id="profileModal" class="modal-overlay">
      <div class="profile-modal">
        <button class="close-modal" onclick="closeProfileModal()">&times;</button>
        <div id="profile-content">
          <!-- Profile content will be loaded here -->
          <div style="text-align:center;padding:40px;"><div class="inline-loading"></div></div>
        </div>
      </div>
    </div>
    
    <!-- ZAPPERS MODAL -->
    <div id="zappersModal" class="modal-overlay">
      <div class="modal-content zappers-modal">
        <button class="close-modal" onclick="closeZappersModal()">&times;</button>
        <div class="zappers-header">Zappers</div>
        <div id="zappers-content">
          <!-- Zappers content will be loaded here -->
          <div style="text-align:center;padding:20px;"><div class="inline-loading"></div></div>
        </div>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-spinner"></div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container"></div>

    <script>
      /***** Global Variables *****/
      let npub = null, profile = null;
      const profileCache = new Map();
      const seenNoteIds = new Set();
      const userZappedNotes = new Set();
      const userFollows = new Set();
      const RELAYS = [
        "wss://relay.damus.io",
        "wss://nos.lol",
        "wss://relay.nostr.band",
        "wss://relay.nostrfreaks.com",
        "wss://relay.snort.social",
        "wss://nostr.wine",
        "wss://relay.current.fyi",
        "wss://purplepag.es",
        "wss://relay.nostr.bg"
      ];
      const zapAmountCache = {}; // noteId -> total sats
      const zapDetailsCache = {}; // noteId -> array of zap events
      const replyCountCache = {}; // noteId -> count of replies
      let oldestTimestamp = Math.floor(Date.now() / 1000);
      let isLoading = false;
      let activeRelayCount = 0;
      let currentZapTarget = null; // { id, pubkey, type } - type can be 'note', 'profile', 'reply'
      const notesContainer = document.getElementById("notes");
      
      /***** Toast Notifications *****/
      function showToast(message) {
        const toast = document.createElement("div");
        toast.className = "toast";
        toast.textContent = message;
        document.body.appendChild(toast);
        getComputedStyle(toast).opacity; // force reflow
        toast.style.opacity = 1;
        setTimeout(() => {
          toast.style.opacity = 0;
          setTimeout(() => toast.remove(), 500);
        }, 3000);
        console.log("[Toast]", message);
      }
      
      /***** Loading Indicator *****/
      function showLoading() {
        document.getElementById("loadingOverlay").style.display = "flex";
        isLoading = true;
      }
      
      function hideLoading() {
        document.getElementById("loadingOverlay").style.display = "none";
        isLoading = false;
      }
      
      /***** Copy to Clipboard Helper *****/
      function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
          showToast("Copied to clipboard");
        }).catch(err => {
          console.error('Failed to copy: ', err);
          showToast("Failed to copy to clipboard");
        });
      }

      /***** Modal Functions *****/
      function openSettingsModal() {
        document.getElementById("settingsModal").style.display = "flex";
        console.log("[Modal] Settings opened");
      }
      
      function closeSettingsModal() {
        document.getElementById("settingsModal").style.display = "none";
        console.log("[Modal] Settings closed");
      }
      
      function scrollToCompose() {
        window.scrollTo({ top: 0, behavior: "smooth" });
        document.getElementById("content").focus();
        console.log("[Scroll] To compose");
      }
      
      function openZapModal(element, type = 'note') {
        // element can be: noteId, {noteId, pubkey}, or pubkey (for profiles)
        let id, pubkey;
        
        if (typeof element === 'string') {
          if (type === 'profile') {
            pubkey = element;
            id = null;
          } else {
            id = element;
            const noteElement = document.getElementById("note-" + id);
            pubkey = noteElement ? noteElement.dataset.pubkey : null;
          }
        } else if (typeof element === 'object') {
          id = element.noteId || element.id;
          pubkey = element.pubkey;
        }
        
        if (!pubkey) {
          showToast("Unable to find recipient information");
          return;
        }
        
        currentZapTarget = { id, pubkey, type };
        
        // Reset form
        document.getElementById("zap-slider").value = 1000;
        document.getElementById("zap-slider-value").textContent = "1000 ⚡";
        document.getElementById("zap-custom").value = "";
        document.getElementById("zap-message").value = "";
        
        // Show modal
        document.getElementById("zapModal").style.display = "flex";
        console.log("[Modal] Zap opened for", type, id || pubkey);
      }
      
      function closeZapModal() {
        document.getElementById("zapModal").style.display = "none";
        currentZapTarget = null;
        console.log("[Modal] Zap closed");
      }
      
      function setZapAmount(amount) {
        document.getElementById("zap-slider").value = amount;
        updateZapSlider(amount);
      }
      
      function updateZapSlider(value) {
        document.getElementById("zap-slider-value").textContent = `${value} ⚡`;
      }
      
      function setZapCustom() {
        const custom = document.getElementById("zap-custom").value;
        if (custom && parseInt(custom) > 0) {
          document.getElementById("zap-slider").value = custom;
          updateZapSlider(custom);
        }
      }
      
      async function openProfileModal(pubkey) {
        if (!pubkey) return;
        
        const modal = document.getElementById("profileModal");
        const content = document.getElementById("profile-content");
        
        // Clear previous content and show loading
        content.innerHTML = '<div style="text-align:center;padding:40px;"><div class="inline-loading"></div></div>';
        modal.style.display = "flex";
        
        try {
          // Fetch basic profile
          const profileData = await fetchProfile(pubkey);
          const isFollowing = userFollows.has(pubkey);
          
          // Start building HTML
          let html = `
            <div class="profile-header">
              <img src="${profileData.banner || '#EF8C56'}" 
                   alt="Banner" 
                   class="profile-banner"
                   onerror="this.style.backgroundColor='#EF8C56'; this.onerror=null; this.removeAttribute('src');">
              <img src="${profileData.picture || "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23ccc'/%3E%3C/svg%3E"}" 
                   alt="Profile" 
                   class="profile-avatar" 
                   onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'48\\' height=\\'48\\' viewBox=\\'0 0 24 24\\'%3E%3Ccircle cx=\\'12\\' cy=\\'12\\' r=\\'10\\' fill=\\'%23ccc\\'/%3E%3C/svg%3E'">
            </div>
            <div class="profile-details">
              <div class="profile-name">${profileData.name || pubkey.slice(0, 8)}</div>
              <div class="profile-npub" onclick="copyToClipboard('${pubkey}')">
                ${pubkey.slice(0, 8)}...${pubkey.slice(-8)} 
                <button class="copy-button">📋</button>
              </div>
          `;
          
          // Add bio if available
          if (profileData.about) {
            html += `<div class="profile-bio">${linkifyText(profileData.about)}</div>`;
          }
          
          // Add action buttons (follow/unfollow, zap)
          if (pubkey !== npub) {
            html += `
              <div class="profile-actions">
                <button class="${isFollowing ? 'unfollow-button' : 'follow-button'}" 
                        onclick="${isFollowing ? 'unfollowUser' : 'followUser'}('${pubkey}')">
                  ${isFollowing ? 'Unfollow' : 'Follow'}
                </button>
                <button class="zap-profile-button" onclick="openZapModal('${pubkey}', 'profile')">
                  ⚡ Zap
                </button>
              </div>
            `;
          }
          
          // Add links if available
          if (profileData.website || profileData.lud16) {
            html += `<div class="profile-links">`;
            
            if (profileData.website) {
              html += `
                <div class="profile-link">
                  🌐 <a href="${profileData.website}" target="_blank" rel="noopener">${profileData.website}</a>
                </div>
              `;
            }
            
            if (profileData.lud16) {
              html += `
                <div class="profile-link">
                  ⚡ <span>${profileData.lud16}</span>
                </div>
              `;
            }
            
            html += `</div>`;
          }
          
          // Add placeholder for recent notes
          html += `
            <div class="profile-notes">
              <div class="profile-notes-title">
                Recent Notes
                <a href="#" onclick="fetchMoreProfileNotes('${pubkey}')">View All</a>
              </div>
              <div id="profile-notes-${pubkey}" class="profile-notes-list">
                <div style="text-align:center;padding:20px;"><div class="inline-loading"></div></div>
              </div>
            </div>
          `;
          
          html += `</div>`; // Close profile-details
          
          content.innerHTML = html;
          
          // Fetch recent notes asynchronously
          fetchRecentProfileNotes(pubkey);
          
        } catch (error) {
          console.error("[Profile Modal] Error:", error);
          content.innerHTML = `<div style="text-align:center;padding:20px;">Error loading profile. Please try again.</div>`;
        }
      }
      
      function closeProfileModal() {
        document.getElementById("profileModal").style.display = "none";
      }
      
      async function fetchRecentProfileNotes(pubkey) {
        const container = document.getElementById(`profile-notes-${pubkey}`);
        if (!container) return;
        
        try {
          // Create a subscription to fetch recent notes
          const notes = [];
          const subs = [];
          
          // Query multiple relays
          for (const relay of RELAYS) {
            try {
              const ws = getWebSocket(relay);
              if (ws.readyState !== WebSocket.OPEN) continue;
              
              const subId = `profile-notes-${pubkey}-${Math.random().toString(36).substring(2, 10)}`;
              subs.push({ relay, subId });
              
              ws.send(JSON.stringify([
                "REQ", 
                subId, 
                {
                  kinds: [1],
                  authors: [pubkey],
                  limit: 3
                }
              ]));
              
              // Add event listener
              const handleEvent = (e) => {
                try {
                  const data = JSON.parse(e.data);
                  if (data[0] === "EVENT" && data[1] === subId) {
                    const note = data[2];
                    if (!notes.some(n => n.id === note.id)) {
                      notes.push(note);
                      if (notes.length === 3) {
                        // Unsubscribe when we have 3 notes
                        subs.forEach(s => {
                          const subWs = getWebSocket(s.relay);
                          if (subWs.readyState === WebSocket.OPEN) {
                            subWs.send(JSON.stringify(["CLOSE", s.subId]));
                          }
                        });
                      }
                    }
                  } else if (data[0] === "EOSE" && data[1] === subId) {
                    // End of stored events
                    renderProfileNotes(pubkey, notes);
                  }
                } catch (err) {
                  console.error("[Profile Notes] Error processing event:", err);
                }
              };
              
              ws.addEventListener("message", handleEvent);
              
              // Set a timeout to remove the event listener
              setTimeout(() => {
                ws.removeEventListener("message", handleEvent);
                renderProfileNotes(pubkey, notes);
              }, 3000);
              
            } catch (err) {
              console.error("[Profile Notes] Error subscribing to relay:", err);
            }
          }
          
          // Fallback if no notes are found after 3 seconds
          setTimeout(() => {
            if (notes.length === 0) {
              renderProfileNotes(pubkey, []);
            }
          }, 3000);
          
        } catch (error) {
          console.error("[Profile Notes] Error:", error);
          container.innerHTML = `<div style="text-align:center;padding:10px;">Error loading notes</div>`;
        }
      }
      
      function renderProfileNotes(pubkey, notes) {
        const container = document.getElementById(`profile-notes-${pubkey}`);
        if (!container) return;
        
        if (notes.length === 0) {
          container.innerHTML = `<div style="text-align:center;padding:10px;color:var(--text-light);">No notes found</div>`;
          return;
        }
        
        // Sort notes by created_at (newest first)
        notes.sort((a, b) => b.created_at - a.created_at);
        
        let html = '';
        
        for (const note of notes) {
          const content = note.content.length > 150 ? `${note.content.substring(0, 150)}...` : note.content;
          
          html += `
            <div class="profile-note" onclick="showFullNote('${note.id}')">
              <div class="profile-note-content">${content}</div>
              <div class="profile-note-time">${formatTimestamp(note.created_at)}</div>
            </div>
          `;
        }
        
        container.innerHTML = html;
      }
      
      function showFullNote(noteId) {
        // This function would navigate to the full note view
        // For now, just show a toast
        showToast("Full note view coming soon!");
      }
      
      async function openZappersModal(noteId) {
        const modal = document.getElementById("zappersModal");
        const content = document.getElementById("zappers-content");
        
        // Clear previous content
        content.innerHTML = '<div style="text-align:center;padding:20px;"><div class="inline-loading"></div></div>';
        modal.style.display = "flex";
        
        try {
          // Ensure we have zap details for this note
          await ensureZapDetails(noteId);
          
          const zaps = zapDetailsCache[noteId] || [];
          let totalSats = zapAmountCache[noteId] || 0;
          
          if (zaps.length === 0) {
            content.innerHTML = `<div style="text-align:center;padding:20px;color:var(--text-light);">No zaps yet</div>`;
            return;
          }
          
          // Add total stats
          let html = `
            <div class="zappers-total">
              <span>${zaps.length} zapper${zaps.length !== 1 ? 's' : ''}</span>
              <div class="zappers-amount">
                ${Math.floor(totalSats)} <span>⚡</span>
              </div>
            </div>
            <div class="zappers-list">
          `;
          
          // Sort zaps by amount (highest first)
          const sortedZaps = [...zaps].sort((a, b) => {
            const amtA = parseInt(a.tags.find(t => t[0] === "amount")?.[1] || "0");
            const amtB = parseInt(b.tags.find(t => t[0] === "amount")?.[1] || "0");
            return amtB - amtA;
          });
          
          // Add each zapper
          for (const zap of sortedZaps) {
            const zapProfile = await fetchProfile(zap.pubkey);
            const amtTag = zap.tags.find(t => t[0] === "amount");
            const amt = amtTag ? parseInt(amtTag[1]) / 1000 : 0;
            const comment = zap.content ? `<div class="zapper-comment">${zap.content}</div>` : '';
            
            html += `
              <div class="zapper-card">
                <img src="${zapProfile.picture || "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23ccc'/%3E%3C/svg%3E"}" 
                     alt="Profile" 
                     onclick="openProfileModal('${zap.pubkey}')"
                     onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'32\\' height=\\'32\\' viewBox=\\'0 0 24 24\\'%3E%3Ccircle cx=\\'12\\' cy=\\'12\\' r=\\'10\\' fill=\\'%23ccc\\'/%3E%3C/svg%3E'">
                <div class="zapper-info" onclick="openProfileModal('${zap.pubkey}')">
                  <div class="zapper-name">${zapProfile.name || zap.pubkey.slice(0, 8)}</div>
                  <div class="zapper-time">${formatTimestamp(zap.created_at)}</div>
                  ${comment}
                </div>
                <div class="zapper-amount">
                  ${Math.floor(amt)} <span>⚡</span>
                </div>
              </div>
            `;
          }
          
          html += `</div>`;
          content.innerHTML = html;
          
        } catch (error) {
          console.error("[Zappers Modal] Error:", error);
          content.innerHTML = `<div style="text-align:center;padding:20px;">Error loading zappers. Please try again.</div>`;
        }
      }
      
      function closeZappersModal() {
        document.getElementById("zappersModal").style.display = "none";
      }
      
      /***** Relay Connections & Event Processing *****/
      const wsPool = new Map();
      function getWebSocket(url) {
        if (wsPool.has(url)) {
          const ws = wsPool.get(url);
          if (ws.readyState === WebSocket.OPEN) return ws;
          
          // If ws is connecting, return it
          if (ws.readyState === WebSocket.CONNECTING) return ws;
          
          // Otherwise remove from pool and create new one
          wsPool.delete(url);
        }
        
        const ws = new WebSocket(url);
        wsPool.set(url, ws);
        
        ws.addEventListener("open", () => {
          console.log(`[Relay] Connected to ${url}`);
          activeRelayCount++;
          updateRelayStatus();
        });
        
        ws.addEventListener("close", () => {
          console.log(`[Relay] Disconnected from ${url}`);
          wsPool.delete(url);
          activeRelayCount--;
          updateRelayStatus();
          
          // Reconnect after a delay if the app is still running
          setTimeout(() => {
            if (document.visibilityState !== "hidden") {
              getWebSocket(url);
            }
          }, 3000);
        });
        
        ws.addEventListener("error", (err) => {
          console.error(`[Relay] Error with ${url}:`, err);
        });
        
        return ws;
      }
      
      function updateRelayStatus() {
        // Update UI based on relay status (could add an indicator in the future)
        console.log(`[Relay] Active relays: ${activeRelayCount}/${RELAYS.length}`);
      }
      
      function connectToRelays() {
        activeRelayCount = 0;
        
        RELAYS.forEach((url) => {
          const ws = getWebSocket(url);
          if (ws.readyState === WebSocket.OPEN) {
            subscribeToFeed(ws);
          } else {
            ws.addEventListener("open", () => {
              subscribeToFeed(ws);
            });
          }
        });
      }
      
      function refreshFeed() {
        showToast("Refreshing feed...");
        showLoading();
        
        // Clear all caches and notes
        notesContainer.innerHTML = "";
        document.getElementById("empty-state").style.display = "none";
        seenNoteIds.clear();
        oldestTimestamp = Math.floor(Date.now() / 1000);
        
        // Reconnect to relays
        connectToRelays();
      }
      
      function subscribeToFeed(ws) {
        // Create subscription ID
        const subId = "feed-" + Math.random().toString(36).substring(2, 10);
        
        // Subscribe to main notes (kind 1 with tag "puffpuffpaint")
        ws.send(JSON.stringify([
          "REQ", 
          subId, 
          { 
            kinds: [1], 
            "#t": ["puffpuffpaint"], 
            limit: 50,
            since: Math.floor(Date.now() / 1000) - 86400 * 7 // Last week
          }
        ]));
        
        // Add event listener for processing events
        ws.addEventListener("message", async (e) => {
          try {
            processEvent(e.data);
          } catch (err) {
            console.error("[Relay] Error processing message:", err);
          }
        });
      }
      
      function processEvent(data) {
        try {
          const parsed = JSON.parse(data);
          if (!Array.isArray(parsed) || parsed.length < 2) return;
          
          const [type, subId, event] = parsed;
          
          if (type === "EVENT" && event) {
            // Process different event kinds
            switch (event.kind) {
              case 0: // Metadata event (profile)
                handleProfileEvent(event);
                break;
              case 1: // Text note
                handleNoteEvent(event);
                break;
              case 3: // Follow list
                handleFollowListEvent(event);
                break;
              case 9734: // Zap receipt
                handleZapEvent(event);
                break;
              default:
                // Ignore other event kinds
                break;
            }
          } else if (type === "EOSE") {
            // End of stored events
            if (subId.startsWith("feed-")) {
              setTimeout(() => {
                hideLoading();
                if (notesContainer.children.length === 0) {
                  document.getElementById("empty-state").style.display = "block";
                }
              }, 500);
            }
          }
        } catch (err) {
          console.error("[Event Processing] Error:", err);
        }
      }
      
      function handleProfileEvent(event) {
        try {
          const profile = JSON.parse(event.content);
          
          // Update profile cache
          if (profileCache.has(event.pubkey)) {
            const cachedProfile = profileCache.get(event.pubkey);
            profileCache.set(event.pubkey, { ...cachedProfile, ...profile });
          } else {
            profileCache.set(event.pubkey, profile);
          }
          
          // Update UI elements with the profile if they exist
          updateProfileUI(event.pubkey, profile);
          
        } catch (err) {
          console.error("[Profile Event] Error processing:", err);
        }
      }
      
      function handleNoteEvent(event) {
        try {
          // Check if it's a reply
          const isReply = event.tags && event.tags.some(tag => tag[0] === "e");
          
          if (isReply) {
            // This is a reply/comment
            const parentTags = event.tags.filter(tag => tag[0] === "e");
            for (const parentTag of parentTags) {
              const parentId = parentTag[1];
              
              // Update reply count
              replyCountCache[parentId] = (replyCountCache[parentId] || 0) + 1;
              
              // Update UI
              const replyBadge = document.getElementById("reply-badge-" + parentId);
              if (replyBadge) {
                replyBadge.textContent = replyCountCache[parentId];
              }
              
              // If the replies container is open, add the reply to it
              const repliesContainer = document.getElementById("replies-" + parentId);
              if (repliesContainer && repliesContainer.style.display === "block") {
                createReplyElement(event).then((el) => {
                  if (el) {
                    // Insert reply in chronological order (oldest first)
                    let inserted = false;
                    for (let i = 0; i < repliesContainer.children.length; i++) {
                      const child = repliesContainer.children[i];
                      if (child.classList.contains("reply-input")) continue;
                      
                      if (parseInt(child.dataset.timestamp || 0) > event.created_at) {
                        repliesContainer.insertBefore(el, child);
                        inserted = true;
                        break;
                      }
                    }
                    
                    if (!inserted) {
                      // Add at the end but before reply input if it exists
                      const replyInput = repliesContainer.querySelector(".reply-input");
                      if (replyInput) {
                        repliesContainer.insertBefore(el, replyInput);
                      } else {
                        repliesContainer.appendChild(el);
                      }
                    }
                  }
                });
              }
            }
          } else {
            // This is a main note with "#t": ["puffpuffpaint"]
            const hasPuffTag = event.tags && event.tags.some(tag => tag[0] === "t" && tag[1] === "puffpuffpaint");
            if (hasPuffTag && !seenNoteIds.has(event.id)) {
              if (event.created_at < oldestTimestamp) {
                oldestTimestamp = event.created_at;
              }
              
              handleNewNote(event);
            }
          }
        } catch (err) {
          console.error("[Note Event] Error processing:", err);
        }
      }
      
      function handleFollowListEvent(event) {
        try {
          // Only process follow lists from the current user
          if (event.pubkey === npub) {
            userFollows.clear();
            event.tags.forEach(tag => {
              if (tag[0] === "p") {
                userFollows.add(tag[1]);
              }
            });
            console.log("[Follow] Updated user follows:", userFollows.size);
          }
        } catch (err) {
          console.error("[Follow Event] Error processing:", err);
        }
      }
      
      function handleZapEvent(event) {
        try {
          // Find the note this zap is for
          const noteTag = event.tags.find(tag => tag[0] === "e");
          const profileTag = event.tags.find(tag => tag[0] === "p");
          
          if (noteTag) {
            const noteId = noteTag[1];
            
            // Store the zap event
            if (!zapDetailsCache[noteId]) zapDetailsCache[noteId] = [];
            
            // Check if this zap is already in the cache
            if (!zapDetailsCache[noteId].some(zap => zap.id === event.id)) {
              zapDetailsCache[noteId].push(event);
              
              // Calculate and update zap amount
              const amtTag = event.tags.find(t => t[0] === "amount");
              const amt = amtTag ? parseInt(amtTag[1]) / 1000 : 0;
              zapAmountCache[noteId] = (zapAmountCache[noteId] || 0) + amt;
              
              // Update UI
              const zapBadge = document.getElementById("zap-badge-" + noteId);
              if (zapBadge) {
                zapBadge.textContent = Math.floor(zapAmountCache[noteId]);
              }
              
              // If the current user sent this zap, update the UI to reflect that
              if (event.pubkey === npub) {
                userZappedNotes.add(noteId);
                const zapAction = document.querySelector(`.action[data-zap-target="${noteId}"]`);
                if (zapAction) {
                  zapAction.classList.add("user-zapped");
                }
              }
            }
          }
          
          // For profile zaps (no specific processing yet)
          if (profileTag && !noteTag) {
            const pubkey = profileTag[1];
            // Could add profile zap count here if desired
          }
        } catch (err) {
          console.error("[Zap Event] Error processing:", err);
        }
      }
      
      function loadMoreNotes() {
        if (isLoading) return;
        
        showLoading();
        
        RELAYS.forEach((url) => {
          const ws = getWebSocket(url);
          const subId = "loadMore-" + Math.random().toString(36).substring(2, 10);
          
          const sub = [
            "REQ",
            subId,
            { 
              kinds: [1], 
              "#t": ["puffpuffpaint"], 
              limit: 50, 
              until: oldestTimestamp - 1 
            }
          ];
          
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(sub));
            
            // Set a timeout to prevent hanging on load more
            setTimeout(() => {
              hideLoading();
              ws.send(JSON.stringify(["CLOSE", subId]));
            }, 5000);
          }
        });
        
        console.log("[Relay] Loading more notes until", oldestTimestamp);
      }
      
      window.addEventListener("scroll", () => {
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 300) {
          loadMoreNotes();
        }
      });
      
      function publishToRelays(event) {
        console.log("[Relay] Publishing event", event);
        let publishedCount = 0;
        
        RELAYS.forEach((url) => {
          const ws = getWebSocket(url);
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(["EVENT", event]));
            publishedCount++;
          } else {
            ws.addEventListener("open", () => {
              ws.send(JSON.stringify(["EVENT", event]));
              publishedCount++;
            });
          }
        });
        
        return publishedCount;
      }

      /***** Profile Management *****/
      async function fetchProfile(pubkey) {
        if (profileCache.has(pubkey)) {
          return profileCache.get(pubkey);
        }
        
        // Create a placeholder profile while fetching
        const placeholder = {
          name: pubkey.slice(0, 8),
          picture: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 24 24'%3E%3Ccircle cx='12' cy='12' r='10' fill='%23ccc'/%3E%3C/svg%3E"
        };
        profileCache.set(pubkey, placeholder);
        
        return new Promise((resolve, reject) => {
          let resolved = false;
          const timeout = setTimeout(() => {
            if (!resolved) {
              resolved = true;
              resolve(placeholder);
            }
          }, 3000);
          
          // Query multiple relays for profile
          for (const relay of RELAYS) {
            try {
              const ws = getWebSocket(relay);
              if (ws.readyState !== WebSocket.OPEN) continue;
              
              const subId = `profile-${pubkey}-${Math.random().toString(36).substring(2, 10)}`;
              
              const handleMessage = (e) => {
                try {
                  const data = JSON.parse(e.data);
                  if (data[0] === "EVENT" && data[2].kind === 0 && data[2].pubkey === pubkey) {
                    ws.removeEventListener("message", handleMessage);
                    
                    try {
                      const profile = JSON.parse(data[2].content);
                      const updatedProfile = { ...placeholder, ...profile };
                      profileCache.set(pubkey, updatedProfile);
                      
                      // Update UI
                      updateProfileUI(pubkey, updatedProfile);
                      
                      if (!resolved) {
                        resolved = true;
                        clearTimeout(timeout);
                        resolve(updatedProfile);
                      }
                    } catch (err) {
                      console.error("[Profile] Error parsing content:", err);
                    }
                  } else if (data[0] === "EOSE" && data[1] === subId) {
                    ws.removeEventListener("message", handleMessage);
                    ws.send(JSON.stringify(["CLOSE", subId]));
                  }
                } catch (err) {
                  console.error("[Profile] Error processing message:", err);
                }
              };
              
              ws.addEventListener("message", handleMessage);
              ws.send(JSON.stringify(["REQ", subId, { kinds: [0], authors: [pubkey] }]));
              
              // Set timeout to clean up listener
              setTimeout(() => {
                ws.removeEventListener("message", handleMessage);
              }, 3000);
              
            } catch (err) {
              console.error("[Profile] Error querying relay:", relay, err);
            }
          }
        });
      }
      
      function updateProfileUI(pubkey, profile) {
        // Update profile pictures and names in the UI
        document.querySelectorAll(`[data-pubkey="${pubkey}"]`).forEach(el => {
          const imgElements = el.querySelectorAll('img[data-profile-img="true"]');
          const nameElements = el.querySelectorAll('[data-profile-name="true"]');
          
          imgElements.forEach(img => {
            if (profile.picture) {
              img.src = profile.picture;
            }
          });
          
          nameElements.forEach(name => {
            if (profile.name) {
              name.textContent = profile.name;
            }
          });
        });
        
        // Special case for the compose area
        if (pubkey === npub) {
          const composeAvatar = document.getElementById("compose-avatar");
          const composeName = document.getElementById("compose-name");
          const profilePic = document.getElementById("profile-pic").querySelector("img");
          
          if (composeAvatar && profile.picture) {
            composeAvatar.src = profile.picture;
          }
          
          if (composeName && profile.name) {
            composeName.textContent = profile.name;
          }
          
          if (profilePic && profile.picture) {
            profilePic.src = profile.picture;
          }
        }
      }
      
      /***** Follow Management *****/
      async function loadUserFollows() {
        if (!npub) return;
        
        try {
          console.log("[Follow] Loading user follows...");
          let resolved = false;
          
          // Request follow list from multiple relays
          for (const relay of RELAYS) {
            try {
              const ws = getWebSocket(relay);
              if (ws.readyState !== WebSocket.OPEN) continue;
              
              const subId = `follow-list-${Math.random().toString(36).substring(2, 10)}`;
              
              const handleMessage = (e) => {
                try {
                  const data = JSON.parse(e.data);
                  if (data[0] === "EVENT" && data[2].kind === 3 && data[2].pubkey === npub) {
                    ws.removeEventListener("message", handleMessage);
                    
                    // Update userFollows
                    userFollows.clear();
                    data[2].tags.forEach(tag => {
                      if (tag[0] === "p") {
                        userFollows.add(tag[1]);
                      }
                    });
                    
                    resolved = true;
                    console.log("[Follow] Loaded user follows:", userFollows.size);
                    
                    // Close subscription
                    ws.send(JSON.stringify(["CLOSE", subId]));
                  } else if (data[0] === "EOSE" && data[1] === subId) {
                    ws.removeEventListener("message", handleMessage);
                    ws.send(JSON.stringify(["CLOSE", subId]));
                  }
                } catch (err) {
                  console.error("[Follow] Error processing follow list:", err);
                }
              };
              
              ws.addEventListener("message", handleMessage);
              ws.send(JSON.stringify(["REQ", subId, { kinds: [3], authors: [npub], limit: 1 }]));
              
              // Set timeout to clean up listener
              setTimeout(() => {
                ws.removeEventListener("message", handleMessage);
                if (!resolved) {
                  console.log("[Follow] No follow list found from relay:", relay);
                }
              }, 3000);
              
            } catch (err) {
              console.error("[Follow] Error querying relay:", relay, err);
            }
          }
          
          // Set timeout to resolve even if no response
          setTimeout(() => {
            if (!resolved) {
              console.log("[Follow] No follow list found from any relay");
            }
          }, 5000);
          
        } catch (error) {
          console.error("[Follow] Error loading follows:", error);
        }
      }
      
      async function followUser(pubkey) {
        if (!npub || !window.nostr) {
          showToast("Please connect your Nostr extension");
          return;
        }
        
        try {
          showToast("Processing follow...");
          
          // Copy current follows and add the new one
          const follows = new Set(userFollows);
          follows.add(pubkey);
          
          // Create follow list event
          const event = {
            kind: 3,
            created_at: Math.floor(Date.now() / 1000),
            tags: Array.from(follows).map(p => ["p", p]),
            content: ""
          };
          
          // Sign and publish
          const signedEvent = await window.nostr.signEvent(event);
          const publishCount = publishToRelays(signedEvent);
          
          if (publishCount === 0) {
            throw new Error("Failed to publish to any relay");
          }
          
          // Update local state
          userFollows.add(pubkey);
          
          // Close the modal and show success
          closeProfileModal();
          showToast("You are now following this user");
          
          // Re-open the modal with updated button
          setTimeout(() => {
            openProfileModal(pubkey);
          }, 300);
          
        } catch (error) {
          console.error("[Follow] Error following user:", error);
          showToast("Error following user: " + error.message);
        }
      }
      
      async function unfollowUser(pubkey) {
        if (!npub || !window.nostr) {
          showToast("Please connect your Nostr extension");
          return;
        }
        
        try {
          showToast("Processing unfollow...");
          
          // Copy current follows and remove the user
          const follows = new Set(userFollows);
          follows.delete(pubkey);
          
          // Create follow list event
          const event = {
            kind: 3,
            created_at: Math.floor(Date.now() / 1000),
            tags: Array.from(follows).map(p => ["p", p]),
            content: ""
          };
          
          // Sign and publish
          const signedEvent = await window.nostr.signEvent(event);
          const publishCount = publishToRelays(signedEvent);
          
          if (publishCount === 0) {
            throw new Error("Failed to publish to any relay");
          }
          
          // Update local state
          userFollows.delete(pubkey);
          
          // Close the modal and show success
          closeProfileModal();
          showToast("You unfollowed this user");
          
          // Re-open the modal with updated button
          setTimeout(() => {
            openProfileModal(pubkey);
          }, 300);
          
        } catch (error) {
          console.error("[Follow] Error unfollowing user:", error);
          showToast("Error unfollowing user: " + error.message);
        }
      }

      /***** Note & Reply Management *****/
      async function createNoteElement(note) {
        // Do not show replies as main notes
        if (note.tags && note.tags.some(tag => tag[0] === "e"))
          return null;
          
        if (seenNoteIds.has(note.id)) return null;
        seenNoteIds.add(note.id);
        
        let authorProfile = await fetchProfile(note.pubkey) || {};
        
        const div = document.createElement("div");
        div.className = "note-card";
        div.id = "note-" + note.id;
        div.dataset.timestamp = note.created_at;
        div.dataset.pubkey = note.pubkey;
        
        // Calculate zap total if any
        ensureZapDetails(note.id);
        
        // Get reply count
        const replyCount = replyCountCache[note.id] || 0;
        
        div.innerHTML = `
          <div class="note-header">
            <img src="${authorProfile.picture}" 
                 alt="Profile" 
                 class="avatar" 
                 data-profile-img="true"
                 onclick="openProfileModal('${note.pubkey}')"
                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'48\\' height=\\'48\\' viewBox=\\'0 0 24 24\\'%3E%3Ccircle cx=\\'12\\' cy=\\'12\\' r=\\'10\\' fill=\\'%23ccc\\'/%3E%3C/svg%3E'" />
            <div class="author-info" onclick="openProfileModal('${note.pubkey}')">
              <div class="author-name" data-profile-name="true">${authorProfile.name || note.pubkey.slice(0, 8)}</div>
              <div class="timestamp">${formatTimestamp(note.created_at)}</div>
            </div>
          </div>
          <div class="note-content">${linkifyText(note.content)}</div>
          <div class="note-id" onclick="copyToClipboard('${note.id}')">${note.id.slice(0, 8)}...${note.id.slice(-8)} <button class="copy-button">📋</button></div>
          ${(() => {
            const imgs = note.tags.filter(tag => tag[0] === "r").map(tag => tag[1]);
            return imgs.length
              ? `<div class="media-container ${imgs.length === 1 ? "single" : "multiple"}">
                   ${imgs.map(url => `<img src="${url}" alt="Attached" loading="lazy">`).join("")}
                 </div>`
              : "";
          })()}
          <div class="note-actions">
            <div class="action" onclick="toggleReplies('${note.id}')">
              💬 <span id="reply-badge-${note.id}">${replyCount}</span>
            </div>
            <div class="action ${userZappedNotes.has(note.id) ? 'user-zapped' : ''}" 
                 onclick="openZapModal('${note.id}')"
                 data-zap-target="${note.id}">
              ⚡️ <span id="zap-badge-${note.id}">${Math.floor(zapAmountCache[note.id] || 0)}</span>
            </div>
            <div class="action" onclick="openZappersModal('${note.id}')">
              👥 Zappers
            </div>
          </div>
          <div id="replies-${note.id}" class="replies-container"></div>
        `;
        
        console.log("[Note] Created note element for", note.id);
        
        return div;
      }
      
      function handleNewNote(note) {
        // Do not show replies in main feed
        if (note.tags && note.tags.some(tag => tag[0] === "e"))
          return;
          
        createNoteElement(note).then((el) => {
          if (el) {
            // Hide loading indicator once notes are loaded
            hideLoading();
            
            // Hide empty state if it's showing
            document.getElementById("empty-state").style.display = "none";
            
            // Add note to feed, sorted by timestamp (newest first)
            let inserted = false;
            for (let i = 0; i < notesContainer.children.length; i++) {
              const child = notesContainer.children[i];
              const childTime = parseInt(child.dataset.timestamp || 0);
              
              if (childTime < note.created_at) {
                notesContainer.insertBefore(el, child);
                inserted = true;
                break;
              }
            }
            
            if (!inserted) {
              notesContainer.appendChild(el);
            }
          }
        });
      }
      
      async function publishNote() {
        const content = document.getElementById("content").value;
        const images = Array.from(document.getElementById("media-preview").getElementsByTagName("img"))
                          .map(img => img.dataset.url);
                          
        if (!content.trim() && images.length === 0) {
          showToast("Please add some content or images");
          return;
        }
        
        if (!window.nostr) {
          showToast("Nostr extension not found. Please install a Nostr browser extension.");
          return;
        }
        
        try {
          showLoading();
          const event = {
            kind: 1,
            content,
            created_at: Math.floor(Date.now() / 1000),
            tags: [
              ["t", "puffpuffpaint"],
              ...images.map(url => ["r", url])
            ]
          };
          
          console.log("[Note] Publishing note", event);
          const signedEvent = await window.nostr.signEvent(event);
          const publishCount = publishToRelays(signedEvent);
          
          if (publishCount === 0) {
            throw new Error("Failed to publish to any relay");
          }
          
          // Clear form
          document.getElementById("content").value = "";
          document.getElementById("media-preview").innerHTML = "";
          
          // Add note to feed
          const el = await createNoteElement({ ...event, id: signedEvent.id, pubkey: npub, sig: signedEvent.sig });
          if (el) {
            notesContainer.insertBefore(el, notesContainer.firstChild);
            
            // Hide empty state if it's showing
            document.getElementById("empty-state").style.display = "none";
          }
          
          console.log("[Note] Note published", signedEvent);
          showToast("Note published!");
          hideLoading();
          
        } catch (error) {
          hideLoading();
          console.error("Failed to publish note:", error);
          showToast("Failed to publish note: " + error.message);
        }
      }

      /***** Comments / Replies *****/
      // Toggle (show/hide) the reply thread for a note.
      function toggleReplies(noteId) {
        const container = document.getElementById("replies-" + noteId);
        if (!container) return;
        
        if (container.style.display === "block") {
          container.style.display = "none";
          console.log("[Replies] Hidden for", noteId);
        } else {
          container.style.display = "block";
          
          // If a reply input is not already appended, append it.
          if (!container.querySelector(".reply-input")) {
            container.appendChild(createReplyInput(noteId));
          }
          
          // Load replies if not already loaded
          if (container.childElementCount <= 1) {
            loadReplies(noteId);
          }
          
          console.log("[Replies] Shown for", noteId);
        }
      }
      
      // Create a reply input block dynamically
      function createReplyInput(noteId) {
        const div = document.createElement("div");
        div.className = "reply-input";
        
        const textarea = document.createElement("textarea");
        textarea.placeholder = "Write a comment...";
        textarea.onkeydown = function(event) {
          if (event.key === "Enter" && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            publishReply(noteId, textarea);
          }
        };
        
        const btn = document.createElement("button");
        btn.className = "publish-button";
        btn.textContent = "Comment";
        btn.onclick = function() { publishReply(noteId, textarea); };
        
        div.appendChild(textarea);
        div.appendChild(btn);
        return div;
      }
      
      async function loadReplies(noteId) {
        const replyContainer = document.getElementById("replies-" + noteId);
        if (!replyContainer) return;
        
        // Add loading indicator
        const loadingEl = document.createElement("div");
        loadingEl.style.textAlign = "center";
        loadingEl.style.padding = "20px";
        loadingEl.innerHTML = '<div class="inline-loading"></div>';
        replyContainer.appendChild(loadingEl);
        
        const replies = new Set();
        let replyCount = 0;
        
        // Create subscription ID
        const subId = `replies-${noteId}-${Math.random().toString(36).substring(2, 10)}`;
        
        // Query multiple relays for replies
        for (const relay of RELAYS) {
          try {
            const ws = getWebSocket(relay);
            if (ws.readyState !== WebSocket.OPEN) continue;
            
            ws.send(JSON.stringify([
              "REQ", 
              subId, 
              { 
                kinds: [1], 
                "#e": [noteId], 
                limit: 50 
              }
            ]));
            
            const handleMessage = async (e) => {
              try {
                const data = JSON.parse(e.data);
                if (data[0] === "EVENT" && data[1] === subId) {
                  const reply = data[2];
                  
                  // Only process each reply once
                  if (!replies.has(reply.id)) {
                    replies.add(reply.id);
                    replyCount++;
                    
                    // Create and add reply element
                    const el = await createReplyElement(reply);
                    if (el && replyContainer) {
                      // Remove loading indicator if it exists
                      if (loadingEl.parentNode === replyContainer) {
                        replyContainer.removeChild(loadingEl);
                      }
                      
                      // Add reply in chronological order (oldest first)
                      let inserted = false;
                      const children = Array.from(replyContainer.children);
                      
                      for (let child of children) {
                        if (child.classList.contains("reply-input")) continue;
                        if (child === loadingEl) continue;
                        
                        const childTime = parseInt(child.dataset.timestamp || 0);
                        if (childTime > reply.created_at) {
                          replyContainer.insertBefore(el, child);
                          inserted = true;
                          break;
                        }
                      }
                      
                      if (!inserted) {
                        // Insert before reply input if it exists
                        const replyInput = replyContainer.querySelector(".reply-input");
                        if (replyInput) {
                          replyContainer.insertBefore(el, replyInput);
                        } else {
                          replyContainer.appendChild(el);
                        }
                      }
                    }
                    
                    // Update badge
                    updateReplyBadge(noteId, replyCount);
                  }
                } else if (data[0] === "EOSE" && data[1] === subId) {
                  // End of stored events
                  ws.removeEventListener("message", handleMessage);
                  
                  // Remove loading indicator if it exists and no replies were found
                  if (loadingEl.parentNode === replyContainer && replies.size === 0) {
                    replyContainer.removeChild(loadingEl);
                    
                    // Add "No replies yet" message
                    const emptyEl = document.createElement("div");
                    emptyEl.style.textAlign = "center";
                    emptyEl.style.padding = "15px";
                    emptyEl.style.color = "var(--text-light)";
                    emptyEl.textContent = "No replies yet";
                    replyContainer.insertBefore(emptyEl, replyContainer.querySelector(".reply-input"));
                  }
                }
              } catch (err) {
                console.error("[Replies] Error processing reply:", err);
              }
            };
            
            ws.addEventListener("message", handleMessage);
            
            // Clean up handler after timeout
            setTimeout(() => {
              ws.removeEventListener("message", handleMessage);
              
              // Close subscription
              if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(["CLOSE", subId]));
              }
              
              // Remove loading indicator if it still exists
              if (loadingEl.parentNode === replyContainer) {
                replyContainer.removeChild(loadingEl);
                
                // Add "No replies yet" message if no replies were found
                if (replies.size === 0) {
                  const emptyEl = document.createElement("div");
                  emptyEl.style.textAlign = "center";
                  emptyEl.style.padding = "15px";
                  emptyEl.style.color = "var(--text-light)";
                  emptyEl.textContent = "No replies yet";
                  
                  const replyInput = replyContainer.querySelector(".reply-input");
                  if (replyInput) {
                    replyContainer.insertBefore(emptyEl, replyInput);
                  } else {
                    replyContainer.appendChild(emptyEl);
                  }
                }
              }
            }, 5000);
            
          } catch (err) {
            console.error("[Replies] Error loading from relay:", relay, err);
          }
        }
      }
      
      function updateReplyBadge(noteId, count) {
        replyCountCache[noteId] = count;
        const badge = document.getElementById("reply-badge-" + noteId);
        if (badge) {
          badge.textContent = count;
        }
      }
      
      async function createReplyElement(reply) {
        let authorProfile = await fetchProfile(reply.pubkey);
        
        const div = document.createElement("div");
        div.className = "reply-card";
        div.dataset.pubkey = reply.pubkey;
        div.dataset.id = reply.id;
        div.dataset.timestamp = reply.created_at;
        
        div.innerHTML = `
          <img src="${authorProfile.picture}" 
               alt="Profile" 
               class="avatar" 
               data-profile-img="true"
               onclick="openProfileModal('${reply.pubkey}')"
               onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'32\\' height=\\'32\\' viewBox=\\'0 0 24 24\\'%3E%3Ccircle cx=\\'12\\' cy=\\'12\\' r=\\'10\\' fill=\\'%23ccc\\'/%3E%3C/svg%3E'" />
          <div class="reply-content">
            <div class="author-info">
              <strong data-profile-name="true" onclick="openProfileModal('${reply.pubkey}')">
                ${authorProfile.name || reply.pubkey.slice(0, 8)}
              </strong> 
              <span class="timestamp">${formatTimestamp(reply.created_at)}</span>
            </div>
            <div>${linkifyText(reply.content)}</div>
            <div class="reply-id" onclick="copyToClipboard('${reply.id}')">
              ${reply.id.slice(0, 6)}...${reply.id.slice(-6)} 
              <button class="copy-button">📋</button>
            </div>
            <div class="reply-actions">
              <div class="action ${userZappedNotes.has(reply.id) ? 'user-zapped' : ''}" 
                   onclick="openZapModal({id: '${reply.id}', pubkey: '${reply.pubkey}'}, 'reply')"
                   data-zap-target="${reply.id}">
                ⚡️ <span id="zap-badge-reply-${reply.id}">${Math.floor(zapAmountCache[reply.id] || 0)}</span>
              </div>
            </div>
          </div>
